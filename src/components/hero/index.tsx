/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGame as useGameConf } from "@/hooks/useGame"
import { GLBType } from "@/lib/game-store"
import { OrbitControls, useAnimations } from "@react-three/drei"
import { useFrame } from "@react-three/fiber"
import { CapsuleCollider, RapierRigidBody, RigidBody, vec3 } from "@react-three/rapier"
import { useGame } from "ecctrl"
import { useEffect, useRef } from "react"
import { Group, Quaternion, Vector3 } from "three"
import { useGltfMemo } from "../glb"

const animationSet: Record<string, string> = {
  idle: "",
  walk: "",
  run: "",
  jump: "",
  jumpIdle: "",
  jumpLand: "",
  fall: "", // This is for falling from high sky
  action1: "",
  action2: "",
  action3: "",
}

export function Glb(props: JSX.IntrinsicElements["group"] & GLBType) {
  const group = useRef<Group>()
  const { scene, animations } = useGltfMemo(props.url)
  const { actions } = useAnimations(animations, group)
  const rigidBodyRef = useRef<RapierRigidBody>(null)
  const rb = rigidBodyRef?.current
  const pos = vec3(rb?.translation())
  const scale = props.scale?.at(0)

  useFrame((t) => {
    if (!rb) return
    const { x, y, z } = vec3(rb.translation())
    const newPos = new Vector3(x, y + 2, z)

    // @ts-ignore
    t?.controls?.target?.copy(newPos)
  })

  const animationsKeys = Object.keys(animations)
  const goTo = useGame()?.moveToPoint
  const setMoveToPoint = useGame((state) => state.setMoveToPoint)
  const currentAnimation = goTo ? props.animationSet.walk : props.animationSet.idle

  useEffect(() => {
    Object.keys(actions).forEach((key) => {
      actions[key]?.stop()
    })
    if (currentAnimation) actions[currentAnimation]?.play()
  }, [currentAnimation, animationsKeys, goTo])

  // const currentAnimation = rb?.isMoving ? animationSet?.walk : animationSet?.idle
  // useEffect(() => {
  //   if (!actions || !currentAnimation) return
  //   actions[currentAnimation]?.reset().fadeIn(0.5)?.play()
  //   return () => {
  //     if (!actions || !currentAnimation) return
  //     actions[currentAnimation]?.fadeOut(0.5)
  //   }
  // }, [actions, currentAnimation])
  //
  useEffect(() => {
    if (!rb) return
    if (!goTo) return
    const angle = Math.atan2(goTo.x - pos.x, goTo.z - pos.z)
    const q = new Quaternion()
    const quat = q.setFromAxisAngle(new Vector3(0, 1, 0), angle)
    rb.setRotation(quat, true)

    const distX = goTo.x - pos.x
    const distZ = goTo.z - pos.z
    const dist = Math.sqrt(distX * distX + distZ * distZ)

    // Calculate the normalized direction vector
    const dirX = distX / dist
    const dirZ = distZ / dist
    const speed = scale * 5

    // rb.setBodyType(3, true)
    rb.setLinvel(
      {
        x: dirX * speed,
        y: 0,
        z: dirZ * speed,
      },
      true,
    )
  }, [goTo, rb, pos, scale, animations])
  const [x, y, z] = goTo
  return (
    <group ref={group}>
      <RigidBody name="stop" position={[x, y + 0.2, z]} scale={props.scale} type="fixed">
        <mesh rotation-x={-Math.PI / 2}>
          <ringGeometry args={[0.4, 0.6]} />
          <meshBasicMaterial color={0xff00ff} transparent opacity={1} />
        </mesh>

        {/* <CapsuleCollider args={[1, 0.1]} position={[0, 2, 0]} /> */}
      </RigidBody>

      <OrbitControls makeDefault />
      <RigidBody colliders={false} friction={0} lockRotations ref={rigidBodyRef} position={props.position}>
        <CapsuleCollider
          friction={0}
          onCollisionEnter={(e) => {
            if (e.colliderObject.name === "stop") {
              alert("Stop")
              setMoveToPoint(null)
              rb?.setLinvel(
                {
                  x: 0,
                  y: 0,
                  z: 0,
                },
                true,
              )
            }
          }}
          scale={scale}
          args={[1, 1]}
        >
          <primitive position={[0, -2, 0]} object={scene} />
        </CapsuleCollider>
      </RigidBody>
    </group>
  )
}

/**
 * Keyboard control preset
 */
export const keyboardMap = [
  { name: "forward", keys: ["ArrowUp", "KeyW"] },
  { name: "backward", keys: ["ArrowDown", "KeyS"] },
  { name: "leftward", keys: ["ArrowLeft", "KeyA"] },
  { name: "rightward", keys: ["ArrowRight", "KeyD"] },
  { name: "jump", keys: ["Space"] },
  { name: "run", keys: ["Shift"] },
  { name: "action1", keys: ["1"] },
  { name: "action2", keys: ["2"] },
  { name: "action3", keys: ["3"] },
  { name: "action4", keys: ["KeyF"] },
]

export function Hero() {
  const { data } = useGameConf()
  const hero = data?.gameConf?.glbs?.find((c) => c?.type === "hero")
  return <Glb {...hero} />
}
